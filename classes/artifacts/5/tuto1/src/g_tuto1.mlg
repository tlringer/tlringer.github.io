DECLARE PLUGIN "tuto1_plugin"

{

(*
  This is a modified version of the Coq plugin tutorial.
  TODO explain, explain class format
 *)
open Pp
open Stdarg

}

(*** Defining terms ***)

(*
 * To define a term, we start similarly to our intern functionality,
 * then we call another function. We define this function in
 * the Simple_declare module.
 *
 * The line #[ poly = Attributes.polymorphic ] says that this command accepts
 * polymorphic attributes.
 * @SkySkimmer: Here, poly is what the result is bound to in the
 * rule's code. Multiple attributes may be used separated by ;, and we have
 * punning so foo is equivalent to foo = foo.
 *
 * The declare_definition function returns the reference
 * that was defined. This reference will be present in the new environment.
 * If you want to refer to it later in your plugin, you must use an
 * updated environment and the constructed reference.
 *
 * Note since we are now defining a term, we must classify this
 * as a side-effect (CLASSIFIED AS SIDEFF).
 *)
VERNAC COMMAND EXTEND MyDefine CLASSIFIED AS SIDEFF
| [ "MyDefine" ident(i) ":=" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t) = Termutils.internalize env sigma e in
     ignore (Termutils.define i sigma t)
   }
END

(*** Checking terms ***)

(*
 * These are two commands for simple type-checking of terms.
 * The bodies and explanations of the differences are in simple_check.ml.
 *)

VERNAC COMMAND EXTEND Check1 CLASSIFIED AS QUERY
| [ "MyCheck" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t) = Termutils.internalize env sigma e in
     let (sigma, typ) = Termutils.type_check env sigma t in
     Feedback.msg_notice (Termutils.print env sigma typ)
   }
END

(*** Definitionl Equality ***)

(*
 * This command checks if there is a possible assignment of
 * constraints in the state under which the two terms are
 * definitionally equal.
 *)
VERNAC COMMAND EXTEND Convertible CLASSIFIED AS QUERY
| [ "Equal" constr(e1) constr(e2) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t1) = Termutils.internalize env sigma e1 in
     let (sigma, t2) = Termutils.internalize env sigma e2 in
     match Termutils.equal env sigma t1 t2 with
     | Some _ ->
        Feedback.msg_notice (strbrk "Yes :)")
     | None ->
        Feedback.msg_notice (strbrk "No :(")
   }
END
