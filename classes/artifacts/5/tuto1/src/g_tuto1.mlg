DECLARE PLUGIN "tuto1_plugin"

{

(*
  This is a modified version of the Coq plugin tutorial.
  TODO explain, explain class format, explain utils file
 *)
open Pp
open Stdarg

}


(*** Defining terms ***)

(*
 * TODO explain, explain eventual goal of what we do, but cool thing is
 * can recurse over terms and also define new terms inside of a plugin.
 * Let's start with defining. When you write Definition in Coq, you're
 * writing a command. We can write our own version of the same command.
 * Let's do that.
 *
 * The define function returns the reference
 * that was defined. This reference will be present in the new environment.
 * If you want to refer to it later in your plugin, you must use an
 * updated environment and the constructed reference.
 * TODO make simpler to understand, explain ignore
 *
 * Note since we are now defining a term, we must classify this
 * as a side-effect (CLASSIFIED AS SIDEFF).
 *
 * TODO explain env, sigma, intern
 *)
VERNAC COMMAND EXTEND MyDefine CLASSIFIED AS SIDEFF
| [ "MyDefine" ident(i) ":=" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t) = Termutils.internalize env sigma e in
     ignore (Termutils.define i sigma t)
   }
END

(*** Reasoning about terms in a plugin ***)

(*
 * TODO explain: our eventual goal, where we'll start, etc. etc.
 * cool thing is you can define terms, you can also recurse over terms.
 *
 * TODO exercise, explain, point to file
 *)
VERNAC COMMAND EXTEND Depth CLASSIFIED AS SIDEFF
| [ "Depth" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t) = Termutils.internalize env sigma e in
     let (sigma, body) = Termutils.lookup_definition env sigma t in
     let (sigma, depth) = Depth.find_depth env sigma body in
     Feedback.msg_notice (strbrk (string_of_int depth))
   }
END

(*** Checking terms ***)

(*
 * These are two commands for simple type-checking of terms.
 * The bodies and explanations of the differences are in simple_check.ml.
 *)

VERNAC COMMAND EXTEND Check1 CLASSIFIED AS QUERY
| [ "MyCheck" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t) = Termutils.internalize env sigma e in
     let (sigma, typ) = Termutils.type_check env sigma t in
     Feedback.msg_notice (Termutils.print env sigma typ)
   }
END

(*** Definitionl Equality ***)

(*
 * This command checks if there is a possible assignment of
 * constraints in the state under which the two terms are
 * definitionally equal.
 *)
VERNAC COMMAND EXTEND Convertible CLASSIFIED AS QUERY
| [ "Equal" constr(e1) constr(e2) ] ->
   {
     let (sigma, env) = Termutils.global_state () in
     let (sigma, t1) = Termutils.internalize env sigma e1 in
     let (sigma, t2) = Termutils.internalize env sigma e2 in
     match Termutils.equal env sigma t1 t2 with
     | Some _ ->
        Feedback.msg_notice (strbrk "Yes :)")
     | None ->
        Feedback.msg_notice (strbrk "No :(")
   }
END
