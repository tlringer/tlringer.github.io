DECLARE PLUGIN "tuto1_plugin"

{

(*
  This is a modified version of the Coq plugin tutorial.
  TODO explain, explain class format
 *)
open Ltac_plugin
open Pp
open Stdarg

}

(*** Interning terms ***)

(*
 * The next step is to make something of parsed expression.
 * Interesting information in interp/constrintern.mli.
 *
 * When you read in constr(e), e will have type Constrexpr.constr_expr,
 * which is defined in pretyping/constrexpr.ml. Your plugin
 * will want a different representation.
 *
 * The important function is Constrintern.interp_constr_evars,
 * which converts between a constr_expr and an
 * (EConstr.constr, evar_map) pair. This essentially contains
 * an internal representation of the term along with some state.
 * For more on the state, read /dev/doc/econstr.md.
 *
 * NOTE ON INTERNING: Always prefer Constrintern.interp_constr_evars
 * over Constrintern.interp_constr. The latter is an internal function
 * not meant for external use.
 *
 * To get your initial environment, call Global.env ().
 * To get state from that environment, call Evd.from_env on that environment.
 * It is important to NEVER use the empty environment or Evd.empty;
 * if you do, you will get confusing errors.
 *
 * NOTE ON STATE: It is important to use the evar_map that is returned to you.
 * Otherwise, you may get cryptic errors later in your plugin.
 * For example, you may get universe inconsistency errors.
 * In general, if a function returns an evar_map to you, that's the one
 * you want to thread through the rest of your command.
 *
 * NOTE ON STYLE: In general, it's better practice to move large
 * chunks of OCaml code like this one into an .ml file. We include
 * this here because it's really important to understand how to
 * thread state in a plugin, and it's easier to see that if it's in the
 * top-level file itself.
 *)
VERNAC COMMAND EXTEND Intern CLASSIFIED AS QUERY
| [ "Intern" constr(e) ] ->
   {
     let (sigma, trm) = Termutils.internalize e in
     Feedback.msg_notice (strbrk "Interned: " ++ Termutils.print trm)
   }
END

(*** Defining terms ***)

(*
 * To define a term, we start similarly to our intern functionality,
 * then we call another function. We define this function in
 * the Simple_declare module.
 *
 * The line #[ poly = Attributes.polymorphic ] says that this command accepts
 * polymorphic attributes.
 * @SkySkimmer: Here, poly is what the result is bound to in the
 * rule's code. Multiple attributes may be used separated by ;, and we have
 * punning so foo is equivalent to foo = foo.
 *
 * The declare_definition function returns the reference
 * that was defined. This reference will be present in the new environment.
 * If you want to refer to it later in your plugin, you must use an
 * updated environment and the constructed reference.
 *
 * Note since we are now defining a term, we must classify this
 * as a side-effect (CLASSIFIED AS SIDEFF).
 *)
VERNAC COMMAND EXTEND MyDefine CLASSIFIED AS SIDEFF
| [ "MyDefine" ident(i) ":=" constr(e) ] ->
   {
     let (sigma, t) = Termutils.internalize e in
     ignore (Termutils.define i sigma t)
   }
END

(*** Printing terms ***)

(*
 * This command takes a name and return its value.  It does less
 * than Print, because it fails on constructors, axioms, and inductive types.
 * It signals an error to the user for unsupported terms.
 *
 * Simple_print contains simple_body_access, which shows how to look up
 * a global reference.
 *)
VERNAC COMMAND EXTEND ExamplePrint CLASSIFIED AS QUERY
| [ "MyPrint" reference(r) ] ->
   {
     let env = Global.env () in
     let sigma = Evd.from_env env in
     try
       let t = Simple_print.simple_body_access (Nametab.global r) in
       Feedback.msg_notice (Printer.pr_econstr_env env sigma t)
     with Failure s ->
       CErrors.user_err (str s)
   }
END

(*
 * This command shows that after you define a new term,
 * you can also look it up. But there's a catch! You need to actually
 * refresh your environment. Otherwise, the defined term
 * will not be in the environment.
 *
 * Using the global reference as opposed to the ID is generally
 * a good idea, otherwise you might end up running into unforeseen
 * problems inside of modules and sections and so on.
 *
 * Inside of simple_body_access, note that it uses Global.env (),
 * which refreshes the environment before looking up the term.
 *)
VERNAC COMMAND EXTEND DefineLookup CLASSIFIED AS SIDEFF
| [ "DefineLookup" ident(i) ":=" constr(e) ] ->
   {
     let env = Global.env () in
     let sigma = Evd.from_env env in
     let (sigma, t) = Constrintern.interp_constr_evars env sigma e in
     let r = Termutils.define i sigma t in
     let print r = strbrk "Defined " ++ Printer.pr_global r ++ strbrk "." in
     Feedback.msg_notice (print r);
     let env = Global.env () in
     let sigma = Evd.from_env env in
     let t = Simple_print.simple_body_access r in
     let print t = strbrk "Found " ++ Printer.pr_econstr_env env sigma t in
     Feedback.msg_notice (print t)
   }
END

(*** Checking terms ***)

(*
 * These are two commands for simple type-checking of terms.
 * The bodies and explanations of the differences are in simple_check.ml.
 *)

VERNAC COMMAND EXTEND Check1 CLASSIFIED AS QUERY
| [ "Check1" constr(e) ] ->
   {
     let env = Global.env () in
     let sigma = Evd.from_env env in
     let (sigma, t) = Constrintern.interp_constr_evars env sigma e in
     let (sigma, typ) = Simple_check.simple_check1 env sigma t in
     Feedback.msg_notice (Printer.pr_econstr_env env sigma typ)
   }
END

VERNAC COMMAND EXTEND Check2 CLASSIFIED AS QUERY
| [ "Check2" constr(e) ] ->
   {
     let env = Global.env () in
     let sigma = Evd.from_env env in
     let (sigma, t) = Constrintern.interp_constr_evars env sigma e in
     let typ = Simple_check.simple_check2 env sigma t in
     Feedback.msg_notice (Printer.pr_econstr_env env sigma typ)
   }
END

(*** Convertibility ***)

(*
 * This command checks if there is a possible assignment of
 * constraints in the state under which the two terms are
 * convertible.
 *)
VERNAC COMMAND EXTEND Convertible CLASSIFIED AS QUERY
| [ "Convertible" constr(e1) constr(e2) ] ->
   {
     let env = Global.env () in
     let sigma = Evd.from_env env in
     let (sigma, t1) = Constrintern.interp_constr_evars env sigma e1 in
     let (sigma, t2) = Constrintern.interp_constr_evars env sigma e2 in
     match Reductionops.infer_conv env sigma t1 t2 with
     | Some _ ->
        Feedback.msg_notice (strbrk "Yes :)")
     | None ->
        Feedback.msg_notice (strbrk "No :(")
   }
END

(*** Introducing terms ***)

(*
 * We can call the tactics defined in Tactics within our tactics.
 * Here we call intros.
 *)
TACTIC EXTEND my_intro
| [ "my_intro" ident(i) ] ->
  { Tactics.introduction i }
END

(*** Exploring proof state ***)

(*
 * This command demonstrates exploring the proof state from within
 * a command.
 *
 * Note that Pfedit.get_current_context gets us the environment
 * and state within a proof, as opposed to the global environment
 * and state. This is important within tactics.
 *)
VERNAC COMMAND EXTEND ExploreProof CLASSIFIED AS QUERY
| ![ proof_query ] [ "ExploreProof" ] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf)
  }
END
