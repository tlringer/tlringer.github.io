DECLARE PLUGIN "tuto1_plugin"

{

(*
  This is a modified version of the Coq plugin tutorial.
  TODO explain, explain class format, explain utils file
 *)
open Pp
open Stdarg
open Termutils
open Exercise

}


(*** Defining terms ***)

(*
 * TODO explain, explain eventual goal of what we do, but cool thing is
 * can recurse over terms and also define new terms inside of a plugin.
 * Let's start with defining. When you write Definition in Coq, you're
 * writing a command. We can write our own version of the same command.
 * Let's do that.
 *
 * The define function returns the reference
 * that was defined. This reference will be present in the new environment.
 * If you want to refer to it later in your plugin, you must use an
 * updated environment and the constructed reference.
 * TODO make simpler to understand, explain ignore
 *
 * Note since we are now defining a term, we must classify this
 * as a side-effect (CLASSIFIED AS SIDEFF).
 *
 * TODO explain env, sigma, intern
 *)
VERNAC COMMAND EXTEND MyDefine CLASSIFIED AS SIDEFF
| [ "MyDefine" ident(i) ":=" constr(e) ] ->
   {
     let sigma, env = global_env () in
     let sigma, t = internalize env e sigma in
     define i t sigma
   }
END

(*** Reasoning about terms in a plugin ***)

(*
 * TODO exercise, explain, point to file (move out of depth, or rename depth to counting)
 *)
VERNAC COMMAND EXTEND Count CLASSIFIED AS SIDEFF
| [ "Count" constr(e1) "in" constr(e2) ] ->
   {
     let sigma, env = global_env () in
     let sigma, t1 = internalize env e1 sigma in
     let sigma, t2 = internalize env e2 sigma in
     let sigma, count = count env t1 t2 sigma in
     Feedback.msg_notice (strbrk (string_of_int count))
   }
END

(*** Both together ***)

(*
 * TODO exercise, explain, point to file (move out of depth, or rename depth to counting)
 *)
VERNAC COMMAND EXTEND Sub CLASSIFIED AS SIDEFF
| [ "Sub" constr_list(src_es) "with" constr_list(dst_es) "in"
      constr(e) "as" ident(i) ] ->
   {
     let sigma, env = global_env () in
     let sigma, srcs = map_state (internalize env) src_es sigma in
     let sigma, dsts = map_state (internalize env) dst_es sigma in
     let sigma, trm = internalize env e sigma in
     let sigma, subbed =
       fold_left_state
         (fun subbed (src, dst) -> sub env (src, dst) subbed)
         trm
         (List.combine srcs dsts)
         sigma
     in Termutils.define i subbed sigma
   }
END
