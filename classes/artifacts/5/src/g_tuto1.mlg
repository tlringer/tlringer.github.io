DECLARE PLUGIN "tuto1_plugin"

{

(*
  This is a modified version of the Coq plugin tutorial.
  TODO explain, explain class format, explain utils file
 *)
open Pp
open Stdarg
open Exercise

}


(*** Defining terms ***)

(*
 * TODO explain, explain eventual goal of what we do, but cool thing is
 * can recurse over terms and also define new terms inside of a plugin.
 * Let's start with defining. When you write Definition in Coq, you're
 * writing a command. We can write our own version of the same command.
 * Let's do that.
 *
 * The define function returns the reference
 * that was defined. This reference will be present in the new environment.
 * If you want to refer to it later in your plugin, you must use an
 * updated environment and the constructed reference.
 * TODO make simpler to understand, explain ignore
 *
 * Note since we are now defining a term, we must classify this
 * as a side-effect (CLASSIFIED AS SIDEFF).
 *
 * TODO explain env, sigma, intern
 *)
VERNAC COMMAND EXTEND MyDefine CLASSIFIED AS SIDEFF
| [ "MyDefine" ident(i) ":=" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_env () in
     let (sigma, t) = Termutils.internalize env e sigma in
     Termutils.define i t sigma
   }
END

(*** Reasoning about terms in a plugin ***)

(*
 * TODO explain: our eventual goal, where we'll start, etc. etc.
 * cool thing is you can define terms, you can also recurse over terms.
 *
 * TODO exercise, explain, point to file
 * TODO rename to arity, change semantics accordingly
 *)
VERNAC COMMAND EXTEND Arity CLASSIFIED AS SIDEFF
| [ "Arity" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_env () in
     let (sigma, t) = Termutils.internalize env e sigma in
     let (sigma, arity) = arity t sigma in
     Feedback.msg_notice (strbrk (string_of_int arity))
   }
END

(*
 * TODO explain: our eventual goal, where we'll start, etc. etc.
 *
 * TODO exercise, explain, point to file
 *)
VERNAC COMMAND EXTEND Nargs CLASSIFIED AS SIDEFF
| [ "Nargs" constr(e) ] ->
   {
     let (sigma, env) = Termutils.global_env () in
     let (sigma, t) = Termutils.internalize env e sigma in
     let (sigma, nargs) = nargs t sigma in
     Feedback.msg_notice (strbrk (string_of_int nargs))
   }
END     

(*
 * TODO exercise, explain, point to file (move out of depth, or rename depth to counting)
 *)
VERNAC COMMAND EXTEND Count CLASSIFIED AS SIDEFF
| [ "Count" constr(e1) "in" "body" constr(e2) ] ->
   {
     let (sigma, env) = Termutils.global_env () in
     let (sigma, t1) = Termutils.internalize env e1 sigma in
     let (sigma, t2) = Termutils.internalize env e2 sigma in
     let (sigma, count) = count_in_body env t1 t2 sigma in
     Feedback.msg_notice (strbrk (string_of_int count))
   }
END

(*** Both together ***)

(*
 * TODO exercise, explain, point to file (move out of depth, or rename depth to counting)
 *)
VERNAC COMMAND EXTEND Sub CLASSIFIED AS SIDEFF
| [ "Sub" constr_list(e1s) "with" constr_list(e2s) "in" constr(e3) "as" ident(i) ] ->
   {
     let (sigma, env) = Termutils.global_env () in
     let (sigma, t1s) = Termutils.map_state (Termutils.internalize env) e1s sigma in
     let (sigma, t2s) = Termutils.map_state (Termutils.internalize env) e2s sigma in
     let (sigma, t3) = Termutils.internalize env e3 sigma in
     let (sigma, subbed) =
       Termutils.fold_left_state
         (fun subbed (t1, t2) -> sub_in env (t1, t2) subbed)
         t3
         (List.combine t1s t2s)
         sigma
     in Termutils.define i subbed sigma
   }
END
